library(data.table)
library(data.tree)
library(foreach)
library(doParallel)

#' Evaluate accuracy of decision tree for rpart library
#' 
#' \code{evaluate.accuracy} calculates accuracy of prediction
#' of decision tree generated by rpart package
#' 
#' @param fit decision tree generated by rpart package
#' @param data data we want to calculate accuracy from
#' @return accuracy
#' @export
evaluate.accuracy <- function(fit, data)
{
  fails = 0
  for (i in 1:length(data$quality))
  {
    pred <- as.data.frame(table(predict(fit, data[i,], type = "class")))
    real <- as.data.frame(table(data$quality[[i]]))
    for (j in 1:length(pred$Freq))
    {
      if (array(pred$Freq[[j]]) == 1)
      {
        if (array(pred$Var1[[j]]) != array(real$Var1))
        {
          fails = fails + 1
        }
        break
      }
    }
  }
  return((length(data$quality) - fails) / length(data$quality))
}

# Checks classification of decision tree and puts
# class labels on leaves
#' 
#' \code{leafs.prediction} Checks classification of 
#' decision tree and puts class labels on leaves
#' 
#' @param tree decision tree generated by this package
#' @param data data we want to calculate prediction from
#' @return tree and accuracy of that tree
#' @export
leafs.prediction <- function(tree, data)
{
  # reseting every leaf
  for (leaf in tree$leaves)
  {
    leaf$cl <- c(0,0,0,0,0,0,0,0,0,0)
  }
  
  for (i in 1:length(data$quality))
  {
    el <- data[i,]
    node <- tree$root
    # every element from data set is classified by tree
    while (1)
    {
      if (el[node$var] < node$val)
      {
        if (is.null(node$children[["lNode"]]))
        {
          if (is.null(node$children[["lLeaf"]])) # if lleaf does not exist
          {
            node$AddChild("lLeaf", cl = c(0,0,0,0,0,0,0,0,0,0)) # create new leaf
          }
          node$children[["lLeaf"]]$cl[[el$quality]] <- node$children[["lLeaf"]]$cl[[el$quality]] + 1 # increment class counter
          break
        }
        else
        {
          node <- node$children[["lNode"]] # go to next node
        }
      }
      else
      {
        if (is.null(node$children[["rNode"]]))
        {
          if (is.null(node$children[["rLeaf"]])) # if rleaf does not exist
          {
            node$AddChild("rLeaf", cl = c(0,0,0,0,0,0,0,0,0,0)) # create new leaf
          }
          node$children[["rLeaf"]]$cl[[el$quality]] <- node$children[["rLeaf"]]$cl[[el$quality]] + 1
          break
        }
        else
        {
          node <- node$children[["rNode"]] # go to next node
        }
      }
    }
  }
  # attach classes to leaves on the basis of the biggest count of each class
  # calculates accuracy
  acc <- 0
  for (leaf in tree$leaves)
  {
    maxCount <- 0
    maxCl <- 0
    for (i in 1:10)
    {
      if (maxCount < leaf$cl[[i]])
      {
        maxCount = leaf$cl[[i]]
        maxCl <- i
        next
      }
    }
    leaf$cl <- maxCl
    acc <- acc + maxCount
  }
  return(c("tree" = tree, "accuracy" = acc / length(data$quality)))
}

# Randomly modifies tree
#' 
#' \code{modify.tree} Modifies tree in random manner.
#' 
#' @param tree decision tree generated by this package
#' @param data data we modify tree depending on
#' @return decision tree without leafs
#' @export
modify.tree <- function(tree, data)
{
  Pcut <- 0.2 # probability of removing node
  Pmod <- 0.5 # probability of modifying node
  Pcre <- 1 - Pcut - Pmod # probability of creating node
  Pl <- 0.5 #probabilty of creating left node
  # find node to modify
  node <- tree$leaves[[as.integer(runif(1,1,length(tree$leaves) + 1))]]$parent
  p <- runif(1)
  if (p < Pcut)
  {
    # remove node
    if (!is.null(node$children[["lLeaf"]]))
    {
      node$RemoveChild("lLeaf")
    }
    if (!is.null(node$children[["rLeaf"]]))
    {
      node$RemoveChild("rLeaf")
    }
    if (node$isRoot)
    {
      var <- c(attributes(data)$names[as.integer(runif(1, min = 1, max = length(data)))])
      val <- c(runif(1, min = min(data[as.character(var)], na.rm=T), max = max(data[as.character(var)], na.rm=T)))
      node <- Node$new("Node", var = var, val = val)
    }
    else
    {
      node$parent$RemoveChild(node$name)
    }
  }
  else if (p < Pcut + Pmod)# beacuse Pcut< p < Pmod
  {
    # modify node
    var <- c(attributes(data)$names[as.integer(runif(1, min = 1, max = length(data)))])
    val <- c(runif(1, min = min(data[as.character(var)], na.rm=T), max = max(data[as.character(var)], na.rm=T)))
    node <- Node$new("lNode", var = var, val = val)
  }
  else
  {
    # create new node
    if (runif(1) < Pl)
    {
      # create left node
      if (!is.null(node$children[["lLeaf"]]))
      {
        node$RemoveChild("lLeaf")
      }
      var <- c(attributes(data)$names[as.integer(runif(1, min = 1, max = length(data)))])
      val <- c(runif(1, min = min(data[as.character(var)], na.rm=T), max = max(data[as.character(var)], na.rm=T)))
      node$AddChildNode(Node$new("lNode", var = var, val = val))
    }
    else
    {
      # create right node
      if (!is.null(node$children[["rLeaf"]]))
      {
        node$RemoveChild("rLeaf")
      }
      var <- c(attributes(data)$names[as.integer(runif(1, min = 1, max = length(data)))])
      val <- c(runif(1, min = min(data[as.character(var)], na.rm=T), max = max(data[as.character(var)], na.rm=T)))
      node$AddChildNode(Node$new("rNode", var = var, val = val))
    }
  }
  return(tree)
}
# Tournament
#' 
#' \code{tournament}Tournament of individuals
#' 
#' @param it iterator
#' @param df dataframe
#' @return winner of tournament
#' @export
tournament <- function(it, df)
{
  S <- 2 # tournament size
  v <- as.integer(runif(S, min = 1, max = length(df[,1])))
  sdf <- df[v,]
  sdf <- sdf[order(sdf$acc, decreasing = TRUE),]
  return(c("ind" = sdf$ind[[1]], "acc" = sdf$acc[[1]]))
}
# Selector of evolution algorithm
#' 
#' \code{selector} Selects the best individuals from population
#' 
#' @param population old population of decision trees
#' @param newpopulation new population of decision trees
#' @param data data we select trees depending on
#' @return population that is used in next iteration
#' of evolution algorithm
#' @export
selector <- function(population, newpopulation, data)
{
  oldpopulation <- attr(selector, "prevpop")
  if (is.null(oldpopulation)) {
    oldpopulation <- population
  }
  oldacc <- attr(selector, "prevacc")
  if (is.null(oldacc)) {
    oldacc <- 0
    # evaluates accuracy
    no_cores <- detectCores() - 1
    cl<-makeCluster(no_cores)
    registerDoParallel(cl)
    r <- foreach (tree = oldpopulation,.combine = c, .export = "leafs.prediction") %dopar%  
      leafs.prediction(tree, data)
    for (i in 1:length(population))
    {
      oldacc[[i]] <- r[[2*i]]
      oldpopulation [[i]] <- r[[2*i-1]]
    }
    stopCluster(cl)
  }
  acc <- vector(mode = "integer", length = length(newpopulation))
  # evaluates accuracy
  no_cores <- detectCores() - 1
  cl<-makeCluster(no_cores)
  registerDoParallel(cl)
  r <- foreach (tree = newpopulation,.combine = c, .export = "leafs.prediction") %dopar%  
    leafs.prediction(tree, data)
  for (i in 1:length(newpopulation))
  {
    acc[[i]] <- r[[2*i]]
    newpopulation [[i]] <- r[[2*i-1]]
  }
  pop <- c(oldpopulation, newpopulation)
  ind <- 1:length(pop) # tree indexes in population
  acc <- c(oldacc, acc)
  df <- data.frame(ind, acc)
  # sort
  dfo <- df[order(df$acc, decreasing = TRUE),]
  r <- foreach (count = 1:length(oldpopulation),.combine = c, .export = "tournament") %dopar%  
    tournament(count,dfo)
  #r <- c()
  #for(i in 1:length(oldpopulation))
  #{
    #r <- c(r,tournament(i, dfo))
  #}
  #create final population to return
  retPop <- oldpopulation
  for (i in 1:length(oldpopulation))
  {
    retPop[[i]] <- Clone(pop[[r[[2*i-1]]]])
    oldacc[[i]] <- r[[2*i]]
  }
  stopCluster(cl)
  attr(selector, "prevpop") <- retPop
  attr(selector, "prevacc") <- oldacc
  return(c("population" = retPop, "bestAcc" = dfo$acc[[1]]))
}

# Generate decision tree using evolution algorithm
#' 
#' \code{generate.with.evolution.algorithm} Generate tree
#' using evolution algorithm
#' 
#' @param data data we generate tree depending on
#' @param desiredAccuracy minimum accuracy we want to achieve
#' @return decision tree
#' @export
generate.with.evolution.algorithm <- function(data, desiredAccuracy)
{
  attributes(selector) <- list(prevpop = NULL, prevacc = NULL)
  N <- 10 # size of population
  M <- 10 # maximum number of iterations
  #generate random population
  Population <- c()
  for (i in 1:N)
  {
    var <- c(attributes(data)$names[as.integer(runif(1, min = 1, max = length(data)))])
    val <- c(runif(1, min = min(data[as.character(var)], na.rm=T), max = max(data[as.character(var)], na.rm=T)))
    Population <-c(Population, Node$new("Node", var = var, val = val))
    Population[[i]]  <- leafs.prediction(Population[[i]], data)$tree
  }
  # evolution algorithm loop
  tmp <- 0
  best <- 0
  bestAcc <- 100
  mist <- 0
  NewPopulation <- c()
  for (j in 1:M)
  {
    for (i in 1:N)
    {
      NewPopulation[[i]] <- Clone(Population[[i]])
      modify.tree(NewPopulation[[i]], data)
    }
    r <- selector(Population, NewPopulation, data)
    for (i in 1:N)
    {
      Population[[i]] <- Clone(r[[i]])
    }
    mist[j] <- r$bestAcc
    best <- 1
    if (desiredAccuracy <= r$bestAcc)
    {
      print(j)
      break
    }
    plot(mist,
         xlab="Iteracja",
         ylab="Accuracy najlepszego osobnika",
         col="royalblue1",
         pch=16)
  }
  plot(mist,
       xlab="Iteracja",
       ylab="Accuracy najlepszego osobnika",
       col="royalblue1",
       pch=16)
  return(Population[[best]])
}